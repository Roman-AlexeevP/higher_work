### Зависимость фреймворка

Классическая зависимость от Django ORM, во-первых, зависимость от баз данных все равно присутствует
и при переходе потребуется адаптировать код, во-вторых, вы зависите от Джанго ОРМ и 
если у вас там есть логика, то придется там же навеки и оставить.

В основном логику работы с БД оставляют в отдельном месте и ОРМ только для маппинга, 
но для джанго этого выбора особо нет.

### Зависимость расшаренного формата

Часть сервера записывает данные в одном формате, API читает и фронетенд принимает.
Итого три зависимые между собой сущности, из-за формата данных. Выбор осознанный, 
разве что удобнее генерировать единую схему в одном формате.

### Зависимость зависимости

Получения доступа к сервису БД/Кэш в зависимости от типа сервера и условий разворачивания.
Созданы отдельные конфигурационные файлы для каждого вида сервера и поддерживаются непрерывно.
Выбор неосознанный, но и проблем особо не приносит.

### Зависимость краша

Системы CI/CD и обновления связанные с уязвимостями. Сценарии разворота и скрипты 
так или иначе могут зависеть от этого, поэтому приходится адаптировать, если появляется
мажорное обновление безопасности для софта.
Решение сознательное, так как автоматический деплой экономит слишком много времени.

### Зависимость перебрасывания

Часто используется, когда в качестве используемого модуля выбирается между вариантом для
разработки и для продакшн среды, как Memcashed и кеш в оперативке сервера, 
получается, что при малых данных мы не зависим от первого варианта, но как только надо 
воспроизводить ошибки с продакшена, то все равно приходится обрабатывать перебрасывание в более 
подходящий сервис. Решение зачастую неосознанное и сулит переписывание локальной версии проекта.

### Зависимость инверсии

В данном случае зависимость на уровне контракта класса/интерфейса, нравится как сделано
в системе Trait в rust, делегат должен поддерживать конкретный функционал, поэтому мы 
пользуемся тайп-чекингом и не упускаем плюсы инверсии зависимости. Решение осознанное.


### Зависимость зацикливания

Зависимость от своего же глобального состояние при обработке множества объектов.
Если реализовано не через постепенную обработку чистыми функциями, то можно зациклиться и обрабатывать
данные при ошибке снова и снова. Решается более дискретными вычислениями без побочных эффектов с сохранением 
промежуточных результатов.


### Зависимость высшего порядка

Когда происходит модификация кода библиотеки через наследование, то случаются такие коллапсы.
Сам не встречал, но все эти USerDict, UserList от лукавого, либо композиция, либо
собственный тип данных со всеми проверками

### Зависимость большинства

Здесь скорее всего чаще всего проявляется отсутствие единых стандартов и стайлгайдов.
Поэтому иногда возникают подобные проблемы. Решаются с помощью ревью, обсуждения, командных документов и четкого ТЗ.

### Вывод

Объективно в разработке слишком много бывает зависимостей, начиная от железа и типа ОС до
квалификации и уровня знаний людей. Поэтому важно минимизировать попытки сцепления с конкретной технологией или платформой,
 или же сделать так, чтобы условия воспроизведения программы всегда были в ограниченном и контролируемом состоянии.
Невозможно поддерживать все форматы и обработать все ошибки, поэтому мы как разработчики 
должны снижать когнитивную нагрузку с помощью инструментов анализа кода, а также 
работать над качеством абстракций и подходов при работе с задачами.