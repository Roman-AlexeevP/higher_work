### Зависимость фреймворка

Зависимость работы с БД от django ORM, которая не позволяет с комфортом использовать другие ORM.

Решение: распределение логики по всей системе равномерно, вместо концентрации всего в моделях и менеджерах.
Статистика в отдельном сервисе и БД, логика сериализации в сериализаторах, отдельные модели для транспортировки 
и тяжеловесные задачи в отделных тасках.

### Зависимость расшаренного формата

Часть сервера записывает данные в одном формате, API читает и фронетенд принимает.
Итого три зависимые между собой сущности, из-за формата данных. 

Решение: ведение общих моделей в монорепозитории для полной синхронизации. Желательно в общем дял всех формате
как json-schema, например. Это тоже новая зависимость, но контролируемая и в одном месте.

### Зависимость зависимости

Получения доступа к сервису БД/Кэш в зависимости от типа сервера и условий разворачивания.

Решение: Созданы отдельные конфигурационные файлы для каждого вида сервера и поддерживаются непрерывно, также 
для pre-commit поддерживается проверка yaml-файлов.


### Зависимость краша

Системы CI/CD и обновления связанные с уязвимостями. Сценарии разворота и скрипты 
так или иначе могут зависеть от этого, поэтому приходится адаптировать, если появляется
мажорное обновление безопасности для софта.

Решение: поддержка собственных сервисов в локальном контуре и отслеживание новых версий со своевременным обновлением.

### Зависимость перебрасывания

Часто используется, когда в качестве используемого модуля выбирается между вариантом для
разработки и для продакшн среды, как Memcashed и кеш в оперативке сервера, 
получается, что при малых данных мы не зависим от первого варианта, но как только надо 
воспроизводить ошибки с продакшена, то все равно приходится обрабатывать перебрасывание в более 
подходящий сервис.

Решение: изначально закладывается логика работа с прод-сервисом как Memcashed или Redis, логика для локального
Redis и тестового. Тогда для каждого сценария используется подходящий сетап и нет проблем во время работы.

### Зависимость инверсии

В данном случае зависимость на уровне контракта класса/интерфейса.


Решение: для python использовать type-checking, линтеры, прописывать пост-условия и пред-условия.

### Зависимость зацикливания

Зависимость от своего же глобального состояние при обработке множества объектов.
Если реализовано не через постепенную обработку чистыми функциями, то можно зациклиться и обрабатывать
данные при ошибке снова и снова. 

Решение: использование чистых функций с замыканием и переменной-аккумулятором, также внедрить проверку выхода из цикла:
таймаут или кол-во попыток.

### Зависимость высшего порядка

Когда происходит модификация кода библиотеки через наследование, то случаются такие коллапсы.


Решение: не наследоваться от List, DIct, Tuple. Использовать композицию и кастомные классы с атрибутами-примитивами.

### Зависимость большинства

Здесь скорее всего чаще всего проявляется отсутствие единых стандартов и стайлгайдов.

Решение: 
- внедрить pre-commit и общий для всех форматер с линтером.
- Стайлгад по созданию веток и ведению коммитов
- Обозначить на встрече общую политику относительно структуры системы
- Следовать плану архитектора/тех.директора и согласовывать крупные модификации

### Вывод

В основном при борьбе с зависимостями происходит уменьшение влияния зависимости на систему, чем нежели полное ее исключение.
Когда такое возможно, то очевидно стоит избавляться от зависимости. Но текущие продукты с наличием огромного количества зависимостей 
разного плана и размера не способны отказаться от них. Поэтому проводятся такие мероприятия как описаны выше для 
повышения отказоустойчивости системы и ее надежности. Анализ разного вида зависимостей показал, что важно уметь правильно
 их классифицировать и поддерживать слабую связность зависимых компонентов.

