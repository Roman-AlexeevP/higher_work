### 1. Проверка на null/None

Одна из самых больших раздутостей, если не придерживаться null object паттерна.
Как пример делать самым нижним наследником null object и переопределить необходимые методы, чтобы обращение
к потенциально None полям не приводили к сбою программы.

### 2. Валидация

Несколько видов конфигов соблюдают инвариант, что в системе должен оставаться хотя бы один конфигурационный файл
и последний удалять нельзя. И для каждого конфига реализована логика повторно.

Выносим валидатор в отдельную функцию, которая проверяет по расширению файлов и имени директории кол-во настроек.

До:
```python

class Config1:

    def delete(self, name):
        # validation logic

class Config2:

    def delete(self, name):
        # validation logic

```
После:

```python

def exists_at_least_one_in_directory(directory_path: Path, config_ext: str) -> bool:
    pass

class Config1:
    def delete(self, name):
        if not exists_at_least_one_in_directory:
            raise ...
        
class Config2:
    def delete(self, name):
        if not exists_at_least_one_in_directory:
            raise ...

```

### Обработка ошибок в API

Какая-то ошибка должна быть отправлена в json-формате, другая не должна доходить до пользователя, и на уровне
представления приходится по-разному отлавливать ошибки.

До:
```python

def view():

    try:
        do()
    except ValueError as err:
        raise HttpException from err
    except FileNotFoundError as err:
        # do somthing another
```

После:
Вводим для сервиса единый класс для ошибок и вызываем только его, чтобы на глобальном уровне приложения
отработать только конкретный вид ошибок и отправлять в едином формате.
```python

class ServiceError(Exception):
    pass

def service_exception_handler(request: Request, exc: ServiceError):
    msg = str(exc)
    return JSONResponse(
        status_code=HTTP_400_BAD_REQUEST,
        content={"message": msg},
    )
```

Теперь можно вызывать в сервисе исключения, зная в каком формате они пойдут конечному пользователю.


### Выводы

Раздутости в коде заметны по функциям, которые исполняют кардинально разный код, в зависимости от параметров. 
По обработке одной и той же логики в разных местах разными инструментами. Зачастую между собой конкурируют старый и новый код, 
 и разработчики боятся оставить какой-то один вариант, что приводит к поддержке двух видов кода. 
В основном это поправляется выявлением необходимого функционала и вынесением его в новую сущность. 
Либо же выбором более эффективного инструмента из двух доступных в коде.