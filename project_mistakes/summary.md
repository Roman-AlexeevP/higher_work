# 1 Пример

**Было**:

Связь между между слоем API и слоем работы с данными была такой:

**FileManager** -> **API** -> внешний мир

```python

class FileManager:
    """ Здесь происходила вся работа с файлами в системе и возвращалось их содержимое"""
    
@router.get()
async def some_api_endpoint(file_manager=Depends(get_file_manager)):
    """ здесь происходила и обработка ошибок валидации и вычисления с даннными и работа с сетью """

```

В связи с этим большинство изменений как раз приходилось либо на границы системы, либо очень рядом с ними,
что затрудняло разработку.

**Стало**:

Достаточно было расширить цепочку до 3 сущностей, которая уже универсально расширяется:

**FileManager** -> **BusinessService** -> **API** -> внешний мир

```python

class FileManager:
    """ Здесь происходила вся работа с файлами в системе и возвращалось их содержимое"""
    
class SomeService:
    
    def __init__(self, file_manager):
        self.file_manager = file_manager

@router.get()
async def some_api_endpoint(request_data, some_service=Depends(get_some_service)):
    """ Теперь происходит конкретный вызов нужного метода сервиса и обработка 4хх 5хх ошибок """
    api_response_data = some_service.process_data(request_data)
    return api_response_data
```

Так как модульность возросла, теперь можно импортировать методы из сервисов между собой, не опасаясь за детали
реализации и ошибки. Также количество импортов в файлы апи также уменьшилось, все ушли в сервисы.
Границы системы теперь четко описаны в спецификации апи(swagger), неизменны и доступны разработчикам/тестировщикам.


# 2 пример

Обработка исключений происходила таким образом, что, чтобы доставлять до фронтенда детали ошибки приходилось
вызывать HTTPException из слоя работы с файлами, что некорректно. 

было:

```python

class FileManager:
    
    CONST_PATH = "..."
    def is_file_exists(self, filename):
        path = Path(self.CONST_PATH) / filename
        if not path.exists():
            raise HTTPException()

```


Стало:

Под каждую сущность необходимо создать свой тип исключений, чтобы конкретизировать место возникновения ошибок,
Также обрабатывать конкретным способом для FastAPI, что позволит единожды добавлять исключение в систему
и пользоваться единым интерфейсом для ошибок:

```python

class FileManagerError(Exception):
    pass

def filenotfound_exception_handler(request: Request, exc: FileManagerError):
    msg = str(exc)
    return JSONResponse(
        status_code=HTTP_400_BAD_REQUEST,
        content={"message": msg},
    )

# использование
msg = f"Папки нет в заданной директории"
raise FileManagerError(msg)
```

Таким образом мы обрабатываем ошибки нижнего уровня и выстраиваем иерархии python исключений снизу-вверх
и обрабатываем их единым способом, зная, что до конечного пользователя дойдет корректная информация, а разработчики
также смогут использовать унифицированную систему.


# 3 пример

Было:

Пример с импортом модулей как раз как в задании был недавно:
модуль 1 и модуль 2 и также сторонний модуль 3, в котором была по ошибке реализована логика, по принципу "все должно лежать рядом"
Импорт потребовал внесений изменений в деплой и добавил лишний модуль ради пары функций.

Стало:

Необходимая логика вынесена в модуль 2, который и так импортируется модулем 1, а сторонний модуль прекратил существование
в проекте. Границы очерчены на уровне модулей и импортов. 


# Вывод

В основном, действительно важными вещами для проектирования системы становятся четкость и прозрачность интерфейсов,
а именно их границы, и взаимодействие между интерфейсами. Если задать изначально гибкую систему, которая не 
плывет после первых правок, оставаясь в тех же границах, то разработка становится гибкой и эффективной.
Поэтому важно тестировать не сугубо приватные методы через юнит-тестирование, а как раз-таки интерфейсы use-case тестами,
 ui-тестами и интеграциионными, предпринимая именно шаги конечного пользователя. 
Четкие границы интерфейсов с открытой документацией + use-case тесты уже покрывают на мой взгляд 80% проблем
с ознакомлением и поддерживанием ПО.