- избавляться от точек генерации исключений, запрещая соответствующее ошибочное поведение на уровне интерфейса класса;
1) В python сложно представить такую защиту на уровне классов, кроме разве какого-либо контракта на уровне
assert или конкретных условий с последующей валидацией проверки этих условий.
Как пример, мне кажется, что более правильным будет для каждого класса рабоыт с базой явно указывать ее тип,
в отличие от Джанго, например. Так или иначе мы рано или поздно упираемся в специфичную для конкретной СУБД
реализацию, поэтому в конкретные модули я бы разрешал передавать объекты соединения явно, а не как обобщенную
абстракцию. Таким образом не придется ловить специфичные для СУБД ошибки в неопознанных местах.
```python

class MyShinyService:
  
  def __init__(self, db_connector):
    self.db_connector = db_connector

service = MyShinyService(db_connector=MyNosqlConnector())
```

- отказаться от дефолтных конструкторов без параметров, и передавать конструктору обязательные аргументы;
  1) Для многих проблем подобного типа сойдет как минимум убирать Optional при использовании датаклассов.
Например, когда редкому параметру конфига выставляется этот тип и он потом вызывается без проверки, то поиск
превращается в увлекательное приключение.
Решение простое:

```python
import dataclasses


@dataclasses.dataclass
class GameSetting:
  
  difficulty: DifficultType
  some_rare_attribute: Optional[str] = None

# Убираем дефолтное значение и Optional
@dataclasses.dataclass
class GameSetting:
  
  difficulty: DifficultType
  some_rare_attribute: str = "default argument in str format"
```
Если бы мы добавили в коде проверку на None, то потом бы пришлось это делать повторно при расширении, сейчас
мы не даем не проинициализировать этот атрибут чем-то кроме наших продуманных строчек.

2) В классе `Board` для работы со сторонами выставляем в конструкторе 4 стороны(2, смотря как обрабатывать) 
обязательными в конструкторе, чтобы избегать ошибок инициализации доски без сторон
```python

class Board:

    def __init__(self, t_surface: SideData):
        self.t_surface = t_surface
```

Суть в том, что мы проверяем это на этапе написание кода стат. анализатором, и не даем дефолтное значение,
чтобы точно знать, что сторона заполнена нужным классом. 

- избегать увлечения примитивными типами данных, разрабатывать прикладную систему типов
  1) Для проекта работающего с досками создан датакласс стороны с параметром, отвечающим за название/тип стороны,
  чтобы избегать ошибок с распознаванием стороны. До этого сторона явно не обозначалась, теперь количество
  неявного поведения снижено в разы.

```python

SurfaceName = Literal["t_surface", "b_surface", "l_edge", "r_edge", "f_end", "b_end"]

@dataclass
class SideData:
    
    surface_name: SurfaceName

```

2) Для хранения сущностей с координатами в 2Д-платформере хранить коллекцию объектов для рендеринга
в классе, у которого изначально инвариант, сущности отсортированы от левой нижний координаты карты:

```python
import dataclasses

@dataclasses.dataclass
class Coordinate:
  x: int
  y: int
  
@dataclasses.dataclass
class Sprite:
  coordinates: Coordinate
  width: float
  height: float

@dataclasses.dataclass 
class SortedSprites:
  sprites: List[Sprite]
  
  def __post_init__(self):
    self.sprites.sort(lambda sprite: sprite.coordinates)
  

```

Благодаря этому в принципе не понадобится каждый вызов коллекции для спрайтов сначала сортировать, а потом 
производить вычисления.

В итоге, могу сказать, что действительно трудно придумывать защиту на уровне интерфейсов, хоть она и является
самой надежной. Самое простое, что может быть использовано для удобства и безопасности - кастомные типы данных,
которые всегда более конкретные и могут быть задокументрированы/протестированы. Необязателньые аргументы в 
конструкторе или пустые варианты инициализаци в принципе чреваты ошибками и означают некий уровень неизвестности
в системе, который обязательно надо планомерно устранять. Мне кажется, что соблюдение системы катсомных типов 
и грамотная работа с конструкторами и ведет к той самой защите на уровне интерфейсов, а если нет, то, по крайней
мере, приближает существенно.